---
layout:     post
title:      比特币与加密货币技术
subtitle:   加密货币简介
date:       2018-08-08
author:     LT
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - cryptocurrency
    - cryptography
---


# Bitcoins and Cyptocurrency Technologies
###### reading notes by lingtao(LT) start from 2018-08-08 

## 第一章 密码学与加密货币简介
### Chapter 1 Introduction to Cryptography & Cryptocurrencies

货币（currency） 是需要一些方法去控制供应量和必需多种的安全属性去避免欺骗（控制货币发行量和类似真伪识别）

加密货币（cryptocurrencies）也需要使用安全措施阻止人们篡改系统状态(tamper with the state of the system),它的的特征之一是与法定货币不一样，它的安全规则只需要单单被技术所执行，并不需要依赖一个中心认证（去中心化）

> 加密货币对密码学的使用广而深，可以防止篡改系统等功能，在理解加密货币之前，我们需要先了解一些加密货币所依赖的密码学的基础知识。

### 1.1 哈希函数

> 特点很明显，哈希函数是一个数学意义上的函数，包含以下三个性质

1. 输入的数值可以是任意长度
2. 输出一个固定长度的结果，(常用)假定256bit。
3. 可以高效的计算，即给定输入，便可以在合理的时间内得到结果。

它有如下几个特性：

1. 碰撞抵抗(**collision-resistance**)：碰撞的意义是对于输入x != y 哈希值H(x) =H(y) ，所以碰撞抵抗就是说没有人能找到这样的x,y使得H(x) =H(y)。(只是计算条件有限的情况下，人力和时间成本找不到这样的）应用：消息摘要：是一个加密散列函数，包含由单向散列公式创建的一串数字。 消息摘要旨在保护数据或媒体的完整性，以检测消息任何部分的更改和更改。

2. 隐秘性(**hiding**):隐秘性的意义在于无法逆向推倒，是某种意义上的 **one-way-function**          or **trapdoor-function** ，攻击者无法从哈希之后的值反推出加密前的值。[应用：commitment]

3. 解题友好(**puzzle-friendliness**):对于任何你想要从哈希函数得到的输出值y，如果k是从一个高小熵分布(**high min-entropy distribution**)中选取的，不可能找到一个x，使H(k//x)=y小于2n，那么我们就说这个哈希函数H是解谜友好的。

#### **SHA-256** 

现在让我们来讨论一个特殊的哈希函数，在这次课程中会经常用到。现在存在着很多的哈希函数，但这有一个是比特币主要使用的，而且它相当的好用，它叫SHA-256。

我们要求的哈希函数能计算任何长度的输入值。fortunately，只要我们能够建立一个计算于固定长度输入值的哈希函数，这儿有一个通用的方法，能将它转换成能够计算任何长度输入值的哈希函数。这种方法叫Merkle-Damgard转换。SHA-256就是一个使用这种方法的常用哈希函数。在常用术语中，基础的固定长度免碰撞哈希函数叫做压缩函数。已经证明，如果基础压缩函数是免碰撞的，那么整体哈希函数都是免碰撞的。

Merkle-Damgard转换是相当简单的。压缩函数接受m长度的输入值，然后产生更短长度为n的输出值，可为任意大小的哈希函数输入值就被分割成长度为m-n的块。具体是这样工作的：将每一个块(m-n)连同前一个输出值块n一起放入压缩函数中，可以注意到，输入值的长度将变为(m-n)+n=m，这就是压缩函数的输入值长度。对于第一个块，没有以前块的输出值，我们就用一个初始化向量(IV)进行替代。这个号码重复使用于每一个哈希函数的命令，在实践中，你可以在一个标准文件中查看它。最后一个块的输出值就是你返回的结果。

SHA-256使用的是接受768位输入值，产生256位输出值的压缩函数，块的大小是256位。下图是SHA-256如何工作的解析图。

![cat_soldier](https://github.com/lingtao13/lingtao13.github.io/blob/master/content_image/bitcoin-1.1.jpg?raw=true)

接下来讨论一下哈希指针(**hash pointer**) 以及哈希结构（**hash structure**）

#### 哈希指针

是在许多系统中我们都将讨论到的一种数据结构，哈希指针指示某些信息存储在何处，我们将这个指针与这些信息的密码学哈希值存储在一起。哈希指针不仅是一种检索信息的方法，同时它也是一种检查信息是否被修改过的方法。


![cat_soldier](https://github.com/lingtao13/lingtao13.github.io/blob/master/content_image/bitcoin-1.2.png?raw=true)

>哈希指针是一个指向存储地点的指针，加上一个针对存储时信息的哈希值

我们可以用哈希指针搭建各种数据结构。我们可以简单的例举些使用指针的数据结构，例如我们熟悉的串联列表，或是二歧搜索树。核心思想是，要使用哈希指针而不是我们通常采用的指针。

#### 区块链

可以用哈希指针构建了一个串联列表，我们将这个数据结构称作区块链。在一个有一连串块的常规串联列表里，每一个块都包含有数据，以及一个指向上一个块的指针。在一个区块链中，前一个块的指针会被哈希指针代替。所以每一个块不仅能告诉我们前一个块的值在哪，同时它也包含该值的摘要，这允许我们去验证这个值是否被篡改过。我们存储列表的开头，这是一个指向最近数据块的常规哈希指针。

![cat_soldier](https://github.com/lingtao13/lingtao13.github.io/blob/master/content_image/bitcoin-1.3.png?raw=true)


>可以发现指针的指向与区块链的形成是相反方向的，后一个数据块指向前一个数据块，这样可以保证整个链的完整性，从任意一个可以往回查到初始节点的位置，这样就防止了数据被篡改。区块链的一个实用案例是防篡改日志。也就是说，我们想要建一个存储一堆数据的日志数据结构，它允许我们在日志的最后加上新的数据。但是一旦有人想要篡改之前的数据，我们就能检查到。


要理解为何一个区块链能够实现这种防篡改属性，让我们来看看如果一个人试图去篡改链条中间的数据，那会发生什么？具体而言，攻击者的目标是在我们只记得哈希指针开头时，就无法检查到篡改的情况下修改数据。为了实现这一目标，攻击者修改了某个块K。由于数据被修改，作为整个块K的哈希，块K+1的哈希将不再匹配。请记住，我们有统计数据保证，新的哈希是不会匹配修改过的内容的，因为哈希函数是免碰撞的，不可能同时匹配修改前后的内容。因此，我们将会检查到在块K中的新数据和块K+1中的哈希值的不一致。当然，攻击者也可以通过继续修改块K+1的哈希去掩盖K中的篡改。然后攻击者可以继续这样做，直到他到达列表开头，这个策略就会失败，因为只要我们将哈希指针的头储存在攻击者无法修改的地方，攻击者就无法在不被检查到的情况下修改任何块。这样的结果是，如果攻击者想要篡改整条链的任何一个地方的数据，为了保持一致性，他将沿着哈希指针一路修改到区块链的开头。他最终将撞上南墙，因为他无法修改列表的开头。因此仅仅通过记住单独这个哈希指针，我们基本就记住了整列防篡改哈希。所以我们可以建立一个包含尽我们需求块数的区块链，而且回到列表的开头，我们称第一个特殊的块叫做创世块。

可以发现区块链的结构就很类似于merkle-damgard结构，相同的安全认证同样类似于他们。

>In cryptography, the Merkle–Damgård construction or Merkle–Damgård hash function is a method of building collision-resistant cryptographic hash functions from collision-resistant one-way compression functions. This construction was used in the design of many popular hash algorithms such as MD5, SHA1 and SHA2.
>
>在密码学里，Merkle-Damgard 结构是一种构造从 **抗碰撞单向压缩函数** 到 **抗碰撞加密哈希函数** 的方法，这种构造方法被普遍应用在许多哈希算法的设计中，比如MD5，SHA1和SHA2


![cat_soldier](https://github.com/lingtao13/lingtao13.github.io/blob/master/content_image/bitcoin-1.4.png?raw=true)

防篡改日志。如果一个攻击者修改了区块链中任何一个地方的数据，这将导致接下来的哈希指针都出现错误。如果我们储存好了列表的开头，即使攻击者修改了所有指针以求与修改的数据一致，开头的指针也会是错误的，那么我们将会检查到恶意篡改。

Merkle树。我们能够利用哈希指针建立的另一个很有用的数据结构是一种二进制树结构，Merkle 树是普遍被认知的一种由哈希指针构建的二进制树，名字跟随其创造者Ralph Merkle。假设我们有很多个包含着数据的块，这些块就是组成树木的叶子。我们将这些块分为两个一组，对于每一组我们建立一个包含两个哈希指针的数据结构，每个指针都指向一个块。这些被指向的数据机构就建起了树的下一个阶级，我们又依次将这些数据分为两个一组，对于每一组我们建立一个包含两个哈希指针的数据结构。我们持续这样做，直到我们到达一个单独的块，称之为数根。

像之前一样，我们只需记得树开头的哈希指针，现在我们就有能力去管理列表中任意一点的哈希指针。这将允许我们确保数据没有被篡改过，因为就如我们所看到的区块链一样，如果有攻击者修改了树下面的一些数据块，那么这将导致高一级的哈希指针不会再匹配。就算他继续修改更高级的块，但是数据的改变已经影响到了他无法修改的树的最顶端，因为我们已经保存好了顶端的数据。因此，任何试图修改任意数据的行为都将被检查到，而我们只需记住顶端的哈希指针。

成员证明。Merkle 树的另外一个优点是，不像我们之前建立的区块链，它允许简洁的成员证明。就是说，有人想要证明一个确切的数据块是Merkle 树中的一员。通常，我们只记住了数根，之后他们需要向我们展示这个区块和通向数根沿途的所有数据块。我们就可以暂时忽略树的其他部分，沿途的数据块就已经足以让我们验证到数根。查看图1.8的图形化描述来了解它的工作机制。

如果在树上有n个节点，那么就只有log(n)个块需要被展示。因为每一个步骤都只需要计算下一级块的哈希，所以这大概只需要log(n)次去证明它。所以即使这个Merkle 树包含了非常多的块，我们依旧可以在一个较短的时间内证明一个成员块。

一个排序Merkle树是一种将数据放在底层，并用一定方式分类的Merkle树。比如按字母表分类，按字典顺序分类，按序号分类，或是按一些其他约定的顺序。

非成员证明。利用排序Merkle树，我们可以证明某个块不属于Merkle树，而且方法也很简单，展示该块前一个块和后一个块的哈希路径，如果这两个块在树里是连贯的，那么这就表明了我们想要证明的块不属于Merkle树。因为如果这个块是包含其中的，那么它将会在展示的两个块的中间，然而这两个连续的块中间并不会有空间。

我们已经讨论过了将哈希指针运用于串联列表和二进制数中，但更通常地，我们可以在任何基于指针的数据结构中使用哈希指针，只要这个数据结构没有循环。如果数据结构是有循环的，那我们将无法让全部的哈希都匹配。你可以试想，在一个非循环的数据结构中，我们可以从没有指针输出的叶子或是数据开始，对其进行哈希计算，然后依次计算到数据的开始。但是在一个循环的数据结构中，这里没有最末尾的东西供我们去计算。





